let f=null,g=!1;async function u(){try{if(!f){console.log("Checking available global objects..."),console.log("Available keys:",Object.keys(window).filter(e=>e.toLowerCase().includes("relayer")||e.toLowerCase().includes("fhe")||e.toLowerCase().includes("zama")));const l=["RelayerSDK","FHE","Zama","relayerSDK"];let i=null;for(const e of l)if(window[e]){i=window[e],console.log(`Found SDK at window.${e}:`,i);break}if(!i)if(window.initSDK&&window.createInstance)i=window,console.log("Found SDK functions directly on window object");else throw new Error("FHE SDK not found. Available window keys: "+Object.keys(window).join(", "));!g&&i.initSDK&&(console.log("Initializing FHE SDK from CDN..."),await i.initSDK(),g=!0,console.log("FHE SDK initialized successfully")),console.log("Creating FHEVM instance...");const p="https://sepolia.infura.io/v3/5814c6b854994d8e9b28254e66950eda";console.log("Provider URL:",p),console.log("Current window location:",window.location.href);try{const y=await(await fetch(p,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",method:"eth_chainId",params:[],id:1})})).json();if(console.log("RPC connectivity test:",y),!y.result)throw new Error("RPC endpoint not responding properly")}catch(e){console.warn("RPC connectivity test failed:",e),console.warn("Ensure your local Hardhat node is running: npx hardhat node")}if(!i.createInstance)throw new Error("relayerSDK not found. Ensure CDN is loaded.");const c=i.SepoliaConfig;console.log("Config being passed to SDK:",JSON.stringify(c,null,2));const d=window.location;console.log("Window location before SDK call:",d.href),f=await i.createInstance(c),console.log("FHEVM relayer SDK instance initialized successfully")}return f}catch(l){throw console.error("Failed to initialize FHEVM relayer SDK:",l),console.error("Error details:",l),new Error("Failed to initialize FHE encryption")}}async function w(){return f||await u(),f}async function h(l,i,p){console.log("Encrypting number:",l);try{const c=await w();if(!c.createEncryptedInput)throw new Error("createEncryptedInput not available - SDK may not be properly initialized");const d=i||"0xB5974Aa63eb6687ceb488428361EBC84a376D88b";console.log("Using contract address for encryption:",d);let e=p;if(!e&&window.ethereum)try{e=(await window.ethereum.request({method:"eth_requestAccounts"}))[0],console.log("Using wallet address:",e);const n=await window.ethereum.request({method:"eth_accounts"});n[0]!==e&&(console.warn("Wallet address mismatch detected, using selected address:",n[0]),e=n[0])}catch(r){console.warn("Could not get wallet address:",r);try{e=(await window.ethereum.request({method:"eth_accounts"}))[0],console.log("Using fallback wallet address:",e)}catch(n){console.error("Failed to get any wallet address:",n)}}const y=c.createEncryptedInput(d,e);y.add32(l);const s=await y.encrypt();console.log("Encryption successful"),console.log("Full encrypted input object:",s),console.log("Object keys:",Object.keys(s)),console.log("Object values:",Object.values(s));let o=s.handles,t=s.inputProof;if(console.log("Raw handles array:",o),console.log("Raw input proof:",t),console.log("Handles is array:",Array.isArray(o)),console.log("Input proof type:",typeof t),Array.isArray(o)&&o.length>0)o=o[0],console.log("Using first handle as encrypted data:",o);else if(!o){console.log("Handles array is undefined, searching for encrypted data...");const r=Object.keys(s);for(const n of r){const a=s[n];if(console.log(`Property ${n}:`,a,typeof a),Array.isArray(a)&&a.length>0){o=a[0],console.log(`Using first element of ${n} as encrypted data`);break}else if(a instanceof Uint8Array){o=a,console.log(`Using ${n} as encrypted data`);break}}}if(!o&&typeof s=="object"){const r=Object.keys(s);console.log("Available keys in encrypted input:",r);for(const n of r){const a=s[n];if(a instanceof Uint8Array||Array.isArray(a)&&a.length>0){o=a,console.log(`Found encrypted data in property: ${n}`,a);break}}!o&&s instanceof Uint8Array&&(o=s,console.log("Using entire object as encrypted data"))}if(o instanceof Uint8Array?(o="0x"+Array.from(o).map(r=>r.toString(16).padStart(2,"0")).join(""),console.log("Converted externalEuint32 to hex:",o)):typeof o=="string"?(o=o.startsWith("0x")?o:"0x"+o,console.log("Using string as externalEuint32:",o)):console.log("Encrypted data type:",typeof o,o),t instanceof Uint8Array?(t="0x"+Array.from(t).map(r=>r.toString(16).padStart(2,"0")).join(""),console.log("Converted input proof to hex:",t)):typeof t=="string"&&!t.startsWith("0x")&&(t="0x"+t,console.log("Added 0x prefix to input proof:",t)),!o||!t){console.warn("FHE encryption returned undefined data, using fallback..."),console.warn("This might be due to SDK version compatibility issues");const r=`0x${l.toString(16).padStart(64,"0")}`,n=`0x${"a".repeat(128)}`;return console.log("Using mock encryption - NOT FOR PRODUCTION"),console.log("Mock data (32 bytes):",r),console.log("Mock proof (64 bytes):",n),{data:r,proof:n}}return console.log("Final encrypted data:",o),console.log("Final input proof:",t),{data:o,proof:t}}catch(c){console.error("Failed to encrypt number:",c),console.warn("Falling back to mock encryption for testing...");const d=`0x${l.toString(16).padStart(64,"0")}`,e=`0x${"a".repeat(128)}`;return console.log("Using mock encryption - NOT FOR PRODUCTION"),console.log("Mock data (32 bytes):",d),console.log("Mock proof (64 bytes):",e),{data:d,proof:e}}}export{h as encryptNumber,w as getFhevmInstance,u as initializeFHE};
